Definition der O-Notation
	*ğ‘“ âˆˆ ğ’ª(ğ‘”) â‡” âˆƒ c>0, nâ‚€ âˆˆ â„• âˆ€ n>nâ‚€: ğ‘“(n) â‰¤ cÂ·ğ‘”(n).
	ğ‘“ âˆˆ ğ’ª(ğ‘”) â‡” âˆ€ c>0 âˆƒ nâ‚€ âˆ€ n>nâ‚€: ğ‘“(n) â‰¥ cÂ·ğ‘”(n).
	*Es gibt Konstanten c, nâ‚€, sodass ab nâ‚€ gilt ğ‘“(n) â‰¤ cÂ·ğ‘”(n).
	ğ‘“ âˆˆ ğ’ª(ğ‘”) â‡” ğ‘“(n)/ğ‘”(n) â†’ âˆ fÃ¼r nâ†’âˆ.

Zeitkostenfunktion einer TM M
	*ğ¾â‚˜(w) ist die Anzahl der Schritte, bis M auf Eingabe w terminiert.
	ğ¾â‚˜(n) = max{|w|=n} LÃ¤nge des Bandinhalts.
	*Die ZeitkomplexitÃ¤t fâ‚˜(n) = max\{ğ¾â‚˜(w) âˆ£ |w|=n\}.
	ğ¾â‚˜(w) misst die Anzahl der ZustÃ¤nde, die M durchlÃ¤uft.
	*Die ZeitkomplexitÃ¤t wird anhand der schnellst mÃ¶glichen TM gemessen.

Simulationsaufwand nichtdeterministischer TMs
	*Eine k-Band-NTM mit Laufzeit fâ‚™(n) lÃ¤sst sich durch eine 1-Band-TM mit Laufzeit 2^O(fâ‚™(n)) simulieren.
	NTM-Laufzeit fâ‚™(n) wird ohne Overhead Ã¼bernommen.
	Simulation einer NTM erfordert niemals mehr als fâ‚™(n) Schritte.



Definition der Klasse P
	*P = â‹ƒ_kâ‰¥1 TIME(náµ), Sprachen die eine deterministische 1-Band-TM in polynomieller Zeit entscheidet.
	P = â‹‚_kâ‰¥1 TIME(náµ).
	*P ist unabhÃ¤ngig von Wahl der Maschine (1-Band, k-Band, RAM).
	P = EXP.

Eigenschaften von P
	*Jede Sprache in P ist auch in NP (P âŠ† NP).
	*Es ist offen, ob P = NP.
	*Algorithmen in P haben fÃ¼r nâ‰ˆ300 praktisch endliche Laufzeit, selbst fÃ¼r hohe Polynome.
	Es gibt Probleme in P, die exponentiell viele Schritte benÃ¶tigen.

Beispiel PATH
	*PATH = {(G,s,t) âˆ£ in G gibt es einen Pfad von s nach t} âˆˆ P.
	PATH âˆ‰ P, da es n^n Knoten-Kombinationen gibt.
	*Eine BFS/DFS-Implementierung auf Turingmaschine lÃ¤uft in O(nÂ³).
	PATH ist NP-vollstÃ¤ndig.



Verifizierer-Charakterisierung von NP
	*NP = {A âˆ£ âˆƒ Verifizierer V, wâˆˆA â‡” âˆƒ c: V akzeptiert (w,c) in poly. Zeit}.
	NP = TIME(náµ) fÃ¼r k>1.
	*NP = â‹ƒ_kâ‰¥1 NTIME(náµ).
	NTIME(náµ) âŠ† P.

Beispiele in NP
	*HAMPATH = {(G,s,t) âˆ£ G enthÃ¤lt Hamilton-Pfad von s nach t} âˆˆ NP.
	*PATH âˆˆ NP.
	*SAT und 3SAT âˆˆ NP.
	*Graph-Clique âˆˆ NP.

Welche Aussage ist falsch?
	P âŠ† NP.
	NP âŠ† EXP.
	*NP âŠ† P.
	P âŠ‚ EXP.



Polynomzeit-Reduktion A â‰¼â‚š B bedeutet â€¦
	*A ist auf B reduzierbar, wenn f berechenbar in poly. Zeit und wâˆˆA â‡” f(w)âˆˆB.
	|w| = |f(w)| fÃ¼r alle wâˆˆÎ£*.
	*TransitivitÃ¤t: A â‰¼â‚š B und B â‰¼â‚š C â‡’ A â‰¼â‚š C.
	A und B mÃ¼ssen das gleiche Alphabet Î£ haben.

NP-Schwere und NP-VollstÃ¤ndigkeit
	*B NP-hart â‡” âˆ€AâˆˆNP: A â‰¼â‚š B.
	*B NP-vollstÃ¤ndig â‡” BâˆˆNP und B NP-hart.
	*B NP-vollstÃ¤ndig und BâˆˆP â‡’ P=NP.
	NP-harte Probleme sind immer entscheidbar.

Satz von Cook-Levin
	*SAT ist NP-vollstÃ¤ndig.
	3SAT âˆˆ P.
	*Jede Sprache in NP lÃ¤sst sich in poly. Zeit auf SAT reduzieren.

WÃ¤hlen Sie die NPâ€vollstÃ¤ndigen Probleme aus:
	*SAT
	*CLIQUE
	*Hamilton-Pfad
	PATH
	Halteproblem

Konsequenzen korollar 3.4.7
	*Ist B NP-schwer, B â‰¼â‚š C und CâˆˆNP, so ist C NP-vollstÃ¤ndig.
	*NP-Schwere Ã¼bertrÃ¤gt sich durch Reduktion.
	*TransitivitÃ¤t von â‰¼â‚š hÃ¤lt die NP-Schwere
	Jede Sprache in NP ist NP-vollstÃ¤ndig.



Beziehungsdiagramm P, NP, EXP
	*P âŠ† NP
	*NP âŠ† EXP
	P âŠ† EXP
	NP âŠ† P.
	NP = EXP.

Welche Aussage trifft zu?
	*Falls SATâˆˆP, folgt P=NP.
	*Falls P=NP, folgt NPâ‰ EXP.

AbschÃ¤tzungen
	*Eine 2-Band-TM kann eine quadratische-Zeit-TM auf O(n) beschleunigen.
	*Eine k-Band-Simulation verursacht hÃ¶chstens polynomialen Overhead.
	Simulation einer Multi-Band-TM auf 1-Band verliert nicht mehr als log-Faktor.

Verifikation vs. Entscheidung
	*Jeder Algorithmus in P kann als NP-Verifizierer fÃ¼r sich selbst dienen.
	Verifizieren (NP) ist stets schwieriger als eine LÃ¶sung zu finden.
	*Ein Verifizierer V akzeptiert (w,c) genau dann, wenn c ein gÃ¼ltiges Zertifikat fÃ¼r w ist.

Singleâ€Choice zur Simulation; Eine NTM mit Laufzeit f(n) lÃ¤sst sich simulieren durch:
	Ein-Band-TM mit Laufzeit O(f(n)).
	*Ein-Band-TM mit Laufzeit 2^O(f(n)).