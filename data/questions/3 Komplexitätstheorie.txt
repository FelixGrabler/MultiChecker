Definition der O-Notation
	*𝑓 ∈ 𝒪(𝑔) ⇔ ∃ c>0, n₀ ∈ ℕ ∀ n>n₀: 𝑓(n) ≤ c·𝑔(n).
	𝑓 ∈ 𝒪(𝑔) ⇔ ∀ c>0 ∃ n₀ ∀ n>n₀: 𝑓(n) ≥ c·𝑔(n).
	*Es gibt Konstanten c, n₀, sodass ab n₀ gilt 𝑓(n) ≤ c·𝑔(n).
	𝑓 ∈ 𝒪(𝑔) ⇔ 𝑓(n)/𝑔(n) → ∞ für n→∞.

Zeitkostenfunktion einer TM M
	*𝐾ₘ(w) ist die Anzahl der Schritte, bis M auf Eingabe w terminiert.
	𝐾ₘ(n) = max{|w|=n} Länge des Bandinhalts.
	*Die Zeitkomplexität fₘ(n) = max\{𝐾ₘ(w) ∣ |w|=n\}.
	𝐾ₘ(w) misst die Anzahl der Zustände, die M durchläuft.

Simulationsaufwand nichtdeterministischer TMs
	*Eine k-Band-NTM mit Laufzeit fₙ(n) lässt sich durch eine 1-Band-TM mit Laufzeit 2^O(fₙ(n)) simulieren.
	NTM-Laufzeit fₙ(n) wird ohne Overhead übernommen.
	*Der 3-Band-Simulator läuft in 2·O(fₙ(n))^2 Zeitschritten.
	Simulation einer NTM erfordert niemals mehr als fₙ(n) Schritte.



Definition der Klasse P
	*P = ⋃ₖ≥1 TIME(nᵏ), Sprachen, die eine deterministische 1-Band-TM in polynomieller Zeit entscheidet.
	P = ⋂ₖ≥1 TIME(nᵏ).
	*P ist unabhängig von Wahl der Maschine (k-Band, RAM).
	P = EXP.

Eigenschaften von P
	*Jede Sprache in P ist auch in NP (P ⊆ NP).
	Es ist offen, ob P ⊂ NP.
	*Algorithmen in P haben für n≈300 praktisch endliche Laufzeit, selbst für hohe Polynome.
	Es gibt Probleme in P, die exponentiell viele Schritte benötigen.

Beispiel PATH
	*PATH = {(G,s,t) ∣ in G gibt es einen Pfad von s nach t} ∈ P.
	PATH ∉ P, da Graphgröße binär kodiert.
	*Eine BFS/DFS-Implementierung auf Turingmaschine läuft in O(n³).
	PATH ist NP-vollständig.



Verifizierer-Charakterisierung von NP
	*NP = {A ∣ ∃ Verifizierer V, w∈A ⇔ ∃ c: V akzeptiert (w,c) in poly. Zeit}.
	NP = TIME(nᵏ) für k>1.
	*NP = ⋃ₖ≥1 NTIME(nᵏ).
	NTIME(nᵏ) ⊆ P.

Beispiele in NP
	*HAMPATH = {(G,s,t) ∣ G enthält Hamilton-Pfad von s nach t} ∈ NP.
	PATH ∉ NP.
	*SAT und 3SAT ∈ NP.
	Graph-Clique ∉ NP.

Welche Aussage ist falsch?
	P ⊆ NP.
	NP ⊆ EXP.
	*NP ⊆ P.
	P ⊂ EXP.



Polynomzeit-Reduktion A ≼ₚ B bedeutet …
	*A ist auf B reduzierbar, wenn f berechenbar in poly. Zeit und w∈A ⇔ f(w)∈B.
	Reduktion darf nur Σ→Σ ohne Größe ändern.
	*Transitivität: A ≼ₚ B und B ≼ₚ C ⇒ A ≼ₚ C.
	A und B müssen gleiche Komplexitätsklasse haben.

NP-Schwere und NP-Vollständigkeit
	*B NP-hart ⇔ ∀A∈NP: A ≼ₚ B.
	B NP-vollständig ⇔ B∈NP und B NP-hart.
	*Ist B NP-vollständig und B∈P ⇒ P=NP.
	NP-harte Probleme sind immer entscheidbar.

Satz von Cook-Levin
	*SAT ist NP-vollständig.
	3SAT ∉ NP.
	*Jede Sprache in NP lässt sich in poly. Zeit auf SAT reduzieren.
	Ursprungssatz gilt nur für 2SAT.

Typische NP-vollständige Probleme
	*CLIQUE, SAT, 3SAT, Hamilton-Pfad, Vertex Cover.
	PATH, HAMPATH und 2SAT sind NP-vollständig.
	*SIMPLEX aus Bonusübung ist NP-vollständig (gerichtete Clique).
	Berechenbarkeitsprobleme wie ATM sind NP-vollständig.

Konsequenzen korollar 3.4.7
	*Ist B NP-schwer, B ≼ₚ C und C∈NP, so ist C NP-vollständig.
	NP-Schwere überträgt sich nicht durch Reduktion.
	*Transitivität von ≼ₚ hält die NP-Schwere.
	Jede Sprache in NP ist NP-vollständig.



Beziehungsdiagramm P, NP, EXP
	*P ⊆ NP ⊆ EXP und P ⊊ EXP.
	NP = EXP bekannt offen.
	*P ⊊ NP folgt aus P⊆NP und P≠NP.
	EXP ⊆ NP, da NTMs simuliert werden können.

Welche Aussage trifft zu?
	Wenn NP⊆P, dann P=NP.
	*Falls SAT∈P, folgt P=NP.
	Wenn P=EXP, dann NP⊊P.
	Wenn 3SAT∉NP, dann SAT∈co-NP.

Abschätzungen
	*Eine 2-Band-TM kann eine quadratische-Zeit-TM auf O(n) beschleunigen.
	Einige Probleme in P bleiben Ω(2ⁿ).
	*Eine k-Band-Simulation verursacht höchstens polynomialen Overhead.
	Simulation einer Multi-Band-TM auf 1-Band verliert nicht mehr als log-Faktor.

Grenzen von NP-Techniken
	*Pumping-Lemma kann Nicht-Untersuchungen für NP-Sprachen nicht beweisen.
	Reduktion zeigt nur NP-Schwere, nicht Nicht-Entscheidbarkeit.
	*Relativierung und Algebrasindizien beschränken Beweismethoden für P≠NP.
	Cook-Levin liefert konstruktive Zertifikate.

Verifikation vs. Entscheidung
	*Verifizieren (NP) ist oft einfacher als Finden (P vs. NP).
	Alle P-Algorithmen lassen sich als Verifizierer einsetzen.
	*Ein Verifizierer ignoriert das Zertifikat vollständig.
	Ein Entscheidungsalgorithmus kann nicht als Verifizierer dienen.

Single‐Choice zur Simulation
	Eine NTM mit Laufzeit f(n) lässt sich simulieren durch:
	Ein-Band-TM mit Laufzeit O(f(n)).
	*Ein-Band-TM mit Laufzeit 2^O(f(n)).
	k-Band-TM mit Laufzeit f(n)·k.
	Eine deterministische RAM-Maschine mit O(log n) Overhead.