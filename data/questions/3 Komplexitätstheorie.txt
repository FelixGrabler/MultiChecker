Definition der O-Notation
	*ğ‘“ âˆˆ ğ’ª(ğ‘”) â‡” âˆƒ c>0, nâ‚€ âˆˆ â„• âˆ€ n>nâ‚€: ğ‘“(n) â‰¤ cÂ·ğ‘”(n).
	ğ‘“ âˆˆ ğ’ª(ğ‘”) â‡” âˆ€ c>0 âˆƒ nâ‚€ âˆ€ n>nâ‚€: ğ‘“(n) â‰¥ cÂ·ğ‘”(n).
	*Es gibt Konstanten c, nâ‚€, sodass ab nâ‚€ gilt ğ‘“(n) â‰¤ cÂ·ğ‘”(n).
	ğ‘“ âˆˆ ğ’ª(ğ‘”) â‡” ğ‘“(n)/ğ‘”(n) â†’ âˆ fÃ¼r nâ†’âˆ.

Zeitkostenfunktion einer TM M
	*ğ¾â‚˜(w) ist die Anzahl der Schritte, bis M auf Eingabe w terminiert.
	ğ¾â‚˜(n) = max{|w|=n} LÃ¤nge des Bandinhalts.
	*Die ZeitkomplexitÃ¤t fâ‚˜(n) = max\{ğ¾â‚˜(w) âˆ£ |w|=n\}.
	ğ¾â‚˜(w) misst die Anzahl der ZustÃ¤nde, die M durchlÃ¤uft.

Simulationsaufwand nichtdeterministischer TMs
	*Eine k-Band-NTM mit Laufzeit fâ‚™(n) lÃ¤sst sich durch eine 1-Band-TM mit Laufzeit 2^O(fâ‚™(n)) simulieren.
	NTM-Laufzeit fâ‚™(n) wird ohne Overhead Ã¼bernommen.
	*Der 3-Band-Simulator lÃ¤uft in 2Â·O(fâ‚™(n))^2 Zeitschritten.
	Simulation einer NTM erfordert niemals mehr als fâ‚™(n) Schritte.



Definition der Klasse P
	*P = â‹ƒâ‚–â‰¥1 TIME(náµ), Sprachen, die eine deterministische 1-Band-TM in polynomieller Zeit entscheidet.
	P = â‹‚â‚–â‰¥1 TIME(náµ).
	*P ist unabhÃ¤ngig von Wahl der Maschine (k-Band, RAM).
	P = EXP.

Eigenschaften von P
	*Jede Sprache in P ist auch in NP (P âŠ† NP).
	Es ist offen, ob P âŠ‚ NP.
	*Algorithmen in P haben fÃ¼r nâ‰ˆ300 praktisch endliche Laufzeit, selbst fÃ¼r hohe Polynome.
	Es gibt Probleme in P, die exponentiell viele Schritte benÃ¶tigen.

Beispiel PATH
	*PATH = {(G,s,t) âˆ£ in G gibt es einen Pfad von s nach t} âˆˆ P.
	PATH âˆ‰ P, da GraphgrÃ¶ÃŸe binÃ¤r kodiert.
	*Eine BFS/DFS-Implementierung auf Turingmaschine lÃ¤uft in O(nÂ³).
	PATH ist NP-vollstÃ¤ndig.



Verifizierer-Charakterisierung von NP
	*NP = {A âˆ£ âˆƒ Verifizierer V, wâˆˆA â‡” âˆƒ c: V akzeptiert (w,c) in poly. Zeit}.
	NP = TIME(náµ) fÃ¼r k>1.
	*NP = â‹ƒâ‚–â‰¥1 NTIME(náµ).
	NTIME(náµ) âŠ† P.

Beispiele in NP
	*HAMPATH = {(G,s,t) âˆ£ G enthÃ¤lt Hamilton-Pfad von s nach t} âˆˆ NP.
	PATH âˆ‰ NP.
	*SAT und 3SAT âˆˆ NP.
	Graph-Clique âˆ‰ NP.

Welche Aussage ist falsch?
	P âŠ† NP.
	NP âŠ† EXP.
	*NP âŠ† P.
	P âŠ‚ EXP.



Polynomzeit-Reduktion A â‰¼â‚š B bedeutet â€¦
	*A ist auf B reduzierbar, wenn f berechenbar in poly. Zeit und wâˆˆA â‡” f(w)âˆˆB.
	Reduktion darf nur Î£â†’Î£ ohne GrÃ¶ÃŸe Ã¤ndern.
	*TransitivitÃ¤t: A â‰¼â‚š B und B â‰¼â‚š C â‡’ A â‰¼â‚š C.
	A und B mÃ¼ssen gleiche KomplexitÃ¤tsklasse haben.

NP-Schwere und NP-VollstÃ¤ndigkeit
	*B NP-hart â‡” âˆ€AâˆˆNP: A â‰¼â‚š B.
	B NP-vollstÃ¤ndig â‡” BâˆˆNP und B NP-hart.
	*Ist B NP-vollstÃ¤ndig und BâˆˆP â‡’ P=NP.
	NP-harte Probleme sind immer entscheidbar.

Satz von Cook-Levin
	*SAT ist NP-vollstÃ¤ndig.
	3SAT âˆ‰ NP.
	*Jede Sprache in NP lÃ¤sst sich in poly. Zeit auf SAT reduzieren.
	Ursprungssatz gilt nur fÃ¼r 2SAT.

Typische NP-vollstÃ¤ndige Probleme
	*CLIQUE, SAT, 3SAT, Hamilton-Pfad, Vertex Cover.
	PATH, HAMPATH und 2SAT sind NP-vollstÃ¤ndig.
	*SIMPLEX aus BonusÃ¼bung ist NP-vollstÃ¤ndig (gerichtete Clique).
	Berechenbarkeitsprobleme wie ATM sind NP-vollstÃ¤ndig.

Konsequenzen korollar 3.4.7
	*Ist B NP-schwer, B â‰¼â‚š C und CâˆˆNP, so ist C NP-vollstÃ¤ndig.
	NP-Schwere Ã¼bertrÃ¤gt sich nicht durch Reduktion.
	*TransitivitÃ¤t von â‰¼â‚š hÃ¤lt die NP-Schwere.
	Jede Sprache in NP ist NP-vollstÃ¤ndig.



Beziehungsdiagramm P, NP, EXP
	*P âŠ† NP âŠ† EXP und P âŠŠ EXP.
	NP = EXP bekannt offen.
	*P âŠŠ NP folgt aus PâŠ†NP und Pâ‰ NP.
	EXP âŠ† NP, da NTMs simuliert werden kÃ¶nnen.

Welche Aussage trifft zu?
	Wenn NPâŠ†P, dann P=NP.
	*Falls SATâˆˆP, folgt P=NP.
	Wenn P=EXP, dann NPâŠŠP.
	Wenn 3SATâˆ‰NP, dann SATâˆˆco-NP.

AbschÃ¤tzungen
	*Eine 2-Band-TM kann eine quadratische-Zeit-TM auf O(n) beschleunigen.
	Einige Probleme in P bleiben Î©(2â¿).
	*Eine k-Band-Simulation verursacht hÃ¶chstens polynomialen Overhead.
	Simulation einer Multi-Band-TM auf 1-Band verliert nicht mehr als log-Faktor.

Grenzen von NP-Techniken
	*Pumping-Lemma kann Nicht-Untersuchungen fÃ¼r NP-Sprachen nicht beweisen.
	Reduktion zeigt nur NP-Schwere, nicht Nicht-Entscheidbarkeit.
	*Relativierung und Algebrasindizien beschrÃ¤nken Beweismethoden fÃ¼r Pâ‰ NP.
	Cook-Levin liefert konstruktive Zertifikate.

Verifikation vs. Entscheidung
	*Verifizieren (NP) ist oft einfacher als Finden (P vs. NP).
	Alle P-Algorithmen lassen sich als Verifizierer einsetzen.
	*Ein Verifizierer ignoriert das Zertifikat vollstÃ¤ndig.
	Ein Entscheidungsalgorithmus kann nicht als Verifizierer dienen.

Singleâ€Choice zur Simulation
	Eine NTM mit Laufzeit f(n) lÃ¤sst sich simulieren durch:
	Ein-Band-TM mit Laufzeit O(f(n)).
	*Ein-Band-TM mit Laufzeit 2^O(f(n)).
	k-Band-TM mit Laufzeit f(n)Â·k.
	Eine deterministische RAM-Maschine mit O(log n) Overhead.